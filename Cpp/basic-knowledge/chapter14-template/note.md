// 初始化顺序
当初始化列表包含多个项目时候，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。

// 使用被包含对象的结果
被包含对象的接口不是共有的，但可以在类方法中使用他，


//私有继承
C++还有另一种实现has-a关系的途径-私有继承。使用私有继承，积累的共有成员和保护成员将将称为派生类的私有成员，这意味着
积累方法将不会称为派生类对象共有接口的一部分，但可以在派生类的成员函数中使用它们。

使用共有继承，基类的共有方法将称为派生类的共有方法。总之，派生类将继承基类的接口：这是is-a关系的一部分。使用私有继承，基类的共有方法将称为派生类的私有方法。总之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。

使用室友继承，类将继承事项。例如，如果从string类派生出Student类，后者将有一个string类组件，可以用于保存字符串。另外，Student方法可以使用String方法来访问String组件。

包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象来表示通过继承或包含添加的对象。

因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所有室友继承可以用来实现has-a关系，

## 使用私有继承还是包含呢？

由于既可以使用包含，也可以使用私有继承来建立has-a关系，那应该使用那种方式呢？大多数C————程序员倾向于使用包含，首先，
它易于理解，类声明中包含表示被包含类的显示命名对象，代码可以通过名称引用这些对象，而使用继承将是关系更加抽象。其次，继承会引起很多问题，尤其是从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或者共享祖先的独立基类，总之，使用包含不太可能遇到这样的麻烦。另外，包含能够使用多个同类的子对象，而继承只能使用要一个这样的对象。

然而，私有继承所提供的特性确实比包含多，例如，假设类包含保护成员，而这样的成员在派生类中是可用的，但在继承基层外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于基层乘此之外的，因此不能访问保护成员，但通过继承得到的是派生类，恶意获取保护成员。

另一种需要使用是由继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是共有的。

## 保护继承

保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected：

使用保护继承时，基类的共有成员和保护成员都将称为派生类的保护成员。和私有继承一样，基类的接口在派生类中是可以用的，但是在基层层次之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的区别就呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的共有方法在派生类中编程了私有方法；使用保护继承时候，基类的公有方法在第二代中变成受保护的，因此第三代派生类可以使用它们。

## 使用using重新定义访问权限

使用保护派生或室友派生时候，基类的共有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用。方法之一是定义一个使用该基类方法的派生类方法。例如，假设希望Student类能够使用valarray类的sum方法，可以在Studeng类的声明中声明一个sum方法，然后像下面这种定义该方法：
double Student::sum() const {
    return std::valarray<double>::sum();  
}

这样Student对象便能够调用Studnet::sum()，后者进而将valarray<double>:sum()方法应用于被包含的valarray对象。

另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用特定的基类成员，即使采用
的是私有派生。；例如，假设希望能够通过Studnet类能够使用valarray的方法min和max，可以在studenti.h的共有部分加入如下的using
声明：

class Student : private std::string, private std::valarray<double> 
{
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
    ...
}

上述using声明使得这两个函数可用，就像它们是Student的共有方法一样。

注意：using声明只使用成员名-没有圆括号、函数特征符和返回类型。例如，为使Student类可以使用valarray的operator[]()方法，只需要在Student类声明的共有部分包含下面的using声明。

using std::valarray<double>::operator[];

这将使两个版本都咳哟i哦那个，便可以删除Student::operator[]()的原型和定义。using声明是适用于继承，二不适用于包含，

有一种老式方式可用于在私有派生类中重新重新声明基类方法，即将方法名放在派生类的共有部分

## 多重继承

多重继承可能会给程序员带来很多新问题。其中两个主要的问题是：从两个不同的基类继承同名方法：从两个或者更多相关基类那里继承同一个类的多个实例。为解决这些问题，需要使用一些新的规则和不同的语法。因此，与使用单继承相比，使用多重继承更加困难，也更容易出现问题。由于这个原因，很多C++用户强烈反对使用多重继承，一些人甚至希望删除多重继承，而喜欢多重继承的人则认为，对于一些特殊的工程来说，多重继承很有用，甚至是必不可少的。；

下面来看一个问题，并介绍有哪些问题以及如何解决它们。要使用多重继承，需要几个类，我们将定义一个抽象基类worker，并使用它派生出waiter和singer类，然后，便可以使用多重继承从Waiter类和Singer类派生出SingingWaiter类。这里使用两个独立的派生来使基类被继承，浙江导致多重继承的大多数麻烦。

## 虚基类
虚基类使得从多个类派生出来的对象只继承一个基类对象。例如，通过在类声明中使用关键字virtual,可以是worker被用作Singer和Waiter的虚基类。

现在SingingWaiter对象将只包含worker对象的一个副本。本子上说，继承的Singer和Waiter对象只共享一个Worker对象，而不是格子引入自己的Wroker对象的副本。因为SingingWaiter现在只包含一个worker子对象，所以可以使用多态。

您可能会有这样的疑问：
  1. 为什么术语使用虚
  2. 为什么不抛弃到基类生为旭的这种方式，而使需行为行为多MI的准则的？
  3. 是否存在麻烦呢

首先，为什么使用术语虚？毕竟虚函数和虚基类之间并不存在明显的联系。C++用户强烈反对引入新的关键字，因为浙江给它们带来很大的呀压力，例如，如果新关键字与重要成语中的重要函数或者变量相同，浙江非常麻烦。因此，C++对这种新特性也使用了关键字virtual-有点像关键字重载。

其次，为什么不抛弃将基类声明为虚的这种方式，而使需行为称为MI的准则呢？第一，在一些情况下，可能需要基类的多个拷贝；第二，将基类作为虚的要求程序完成外的计算，为不需要的工具付出代价是不适当的；第三，这样做是有缺点的。

最后，死否存在麻烦呢？是的，为使虚基类能够工作，需要对C————规则进行调整，必须以不同的方式编写代码。另外，使用虚基类还可能需要修改已存在的代码。

## 新的构造规则
使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，唯一可以出现在初始化列表中的构造函数是即使基类构造函数，但这些构造函数可能需要将信息传递给其基类，例如可能有下面一组构造函数：

class A
{
    int a;
public:
    A(int n=0) : a(n) { }
};

class B : public A
{
    int b;
public:
    B(int m=0,int n=0) : A(n),b(m) { }

};

class C : public B
{
    int c;
public:
    C(int q=0,int m=0,int n=0) : B(m,n),c(q) { }
}

C的构造函数只能调用B类的构造函数，而B类的构造函数只能调用A类的构造函数，这里，C类的构造函数使用值q,并将值m,n传递给B类的构造函数；而B类的构造函数使用值m,并将值n传递给A类的构造函数。

如果Worker是虚基类，则这种信息自动传递将不起作用。例如，对于下面的MI构造函数：
SingingWaiter(const Worker& wk,int p=0,int v=Singer::other) : Waiter(wk,p),Singer(wk,v) { }

存在的问题是，自动传递信息时，将通过2条不同的途径将wk传递给work对象。为便面这种冲突，C++在积累是虚的时，紧急信息通过中间类自动传给积累，因此，上述构造函数将初始化成员panache和voice，但wk参数中的信息将不会传递给Waiter。然而，编译器必须在构造派生对象之前构造积累对象组件，在这种情况下，编译器将使用Worker的默认构造函数。

如果不希望默认构造函数来构造虚积累对象，则需要显式地调用所需的基类构造函数。因此，构造函数应该是这样：
    SingingWaiter(const Worker &wk,int p=0,int v=Singer::other): Worker(wk),Waiter(wk,p),Singer(wk,v) { }

上述代码将显式地调用构造函数worker(const Worker&)。请注意，这种用法是合法的，对于虚基类，必须这样做；但对于非虚基类，则是非法的。

注意：如果类有间接虚基类，则除非只需要使用该虚类的默认构造函数，否则必须显式地调用该虚基类地某个构造函数。
## 哪个方法？
出来修改类构造函数规则外，MI通常还要求调整其他代码。假设要在SingingWaiter类中扩展Show()方法。因为SingingWaiter对象对象没有新地数据成员，所以可能会认为他需要使用继承地方法即可。这引出了第一个问题。假设没有在SingingWaiter类中重新定义Show（）方法，并试图使用SingWaiter对象调用继承的Show（）方法。

对于单继承，如果没有重新定义Show（）,则将使用最近祖先中的定义。而在多继承中，每个直接祖先都有一个Show函数，这使得上述调用是二义的。

注意：多重继承可能导致函数调用的二义性。

可以使用作用域解析运算符来澄清编程者的意图：
SingingWaiter new("Elise",2005,6,soprano);
new.Singer::Show();

然而更好的方法是在SingingWaiter中重新定义Show(),并指出使用哪个Show(),则可以这样做
void SingingWaiter::show() {
    Singer::Show();
}

对于单继承来说，让派生方法调用基类的方法是可以的。


## 有关MI的问题

1. 混合使用虚基类和非虚基类

通过多种途径继承一个基类的派生类的情况。如果基类是虚基类，派生类将包含基类的一个子对象；如果基类不是虚基类，派生类将包含多个子对象。如何混合使用嗯？
假设B被用作C和D 的虚基类，同时被用作类X和Y的非虚基类，二类M是从C、D、X和Y派生出来的。在这种轻盔昂下，类M 从徐派生祖先（C和D）哪里共继承一个B类对象，并从非派生祖先（X和Y）哪里分别继承一个B类子对象。因此，它包含三个B类对象。

2. 虚基类和支配

使用虚基类将改变C++解析二义性的方式，使用非虚基类时，规则很简单。如果类从不同的类哪里继承了两个或更多的同名成员，则使用该成员名，如果没有使用类名进行限定，将导致二义性。但如果使用的是虚基类，则这样做不一定会导致二义性。在这种情况下，如果某个名称优先于其他所有名称，则使用它。
那个一个成员名如何优先于另一个成员名呢？派生类中的名称优先于直接获简介祖先类中的相同名称。
class B{
public:
    short q();
    ...
}

class C : virtual public B
{
public:
    long q();
    int omg();
    ....
}

class D: public C
{
    ...
}

class E: virtual public B
{
private:
    int omg();
    ...
}

class F:public D,public E
{

}

类C中的q()定义优先于类B中的q()定义，因为类C 是从类B 派生出来的，因此F中的方法可以使用q来表示C::q()。另一方面，任何一个omg()赌博国土都不优先于其他ing定义，因为C和E都不是对方的基类。


## 类模板

可以将内置类型或类对象用作类模板Stack<Type>的类型。指针可以吗？例如，可以使用char指针替换程序清单中的string对象嘛？
毕竟，这种指针是处理C-风格字符串的内置方式。答案是可以创建
指针stack,但如果不对程序做重大修改，将无法很好地工作。编译器可以创建类，但使用效果如何就因人而异了。下面解释程序不太使用使用程序stack的原因，然后介绍一个指针stack很有用的例子。

## 正确使用指针stack
使用指针stack的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。把这些放入stack是有意义的，因为每个指针都指向不同的字符串。注意，创建不同指针是调用程序的指针，而不是栈的职责。stack的任务是指针，
而不是创建指针。

## 数组模板实体和非类型参数

模板常用作容器类，这是因为类型参数的概念非常适合于将相同的存储方案用于不同的类型。确实，为容器类提供可重用代码是引入模板的主要动机，所以我们来看看另一个例子，深入讨论模板设计和使用的其他几个方面。具体地说，将讨论一些非类型参数以及如何使用数组来处理继承族。

首先，介绍一个允许数组大小的简单数组模板。一种方法是在类中使用动态数组和构造函数参数来提供元素数目，最后一个版本的Stack模板采用的就是这种方法。另一种方法是使用模板参数来提供常规数组的大小，C++新增的模板array就是这样做的。

关键字class指出T为类型参数，int指出n的类型为int。这种参数称为非类型或表达式参数。假设有下面的声明：
    ArrayTP<double,12> eggweights;

这种导致编译器定义名为ArrayTP<double,12>的类，并创建一个类型ArrayTP<double,12>的eggweight对象。定义类时，编译器将使用double替换T，使用12替换n。

表达式参数有一些限制。表达式参数可以是整形、枚举、引用或指针。因此，double m是不合法的，但doble* rm和double* pm是合法的。另外，模板代码不能修改参数的值，也不能使用参数的地址，所以，在ArrayTP模板中不能使用诸如n++和&n等表达式。另外，实例化模板时，用作表达式参数的值必须是常量表达式。

与Stack中使用的构造函数方法相比，这种改变数组大小的方法有一个有点构造函数方法使用的是通过new和delete管理的堆内存，而表达式参数方法使用的是为自动变量维护的内存stack，这样，执行速度将更快，
尤其是在使用了很多小型数组时。

表达式参数的主要缺点是，每个数组大小都将生成自己的模板。也就是说，下面的声明将生成两个独立的类声明：
ArrayTP<double,12> eggweights;
ArrayTP<double,13> donuts;
但下面的声明值生成一个类声明，并将数组大小信息传递给类的构造函数：
Stack<int> eggs(12);
Stack<int> dunkers(13);

另一个区别是：构造函数方法更通用，这是因为数组大小是作为类成员存储在定义中的。这样可以将一种尺寸的数组赋值给另一种尺寸的数组，也可以创建允许数组大小可变的类。


## 模板多功能性。

可以将用于常规类的技术用于模板类，模板类可以用作基类，也可用作组件类，还可用作其他模板的类型参数。例如：可以使用数组模板实现stack模板，也可以使用数组模板来构造数组-数组元素是基于stack模板的stack,既可以编写下面的代码：

template<typename T>
class Array
{
private:
    T entry;
    ...
};

template<typename Type>
class GrowArray : public Array<Type> {  //inheritance
    ...
}

template<typename Tp>               
class Stack
{
    Array<Tp> ar;    //use an Array<> as a component
    ....
}
...
Array<Stack<int>> asi; //an array of stacks of int



## 递归使用模板

另一个模板多功能性的例子是，可以递归使用模板，例如对于前面的数组模板定义，可以这样使用它：
ArrayTP<ArrayTP<int,5>,10> twodee;

这使得twodee是一个包含10个元素的数组，其中每个元素都是一个包含5个int元素的数组，与之等价的常规数组声明如下：
int twodee[10][5];

请注意：在模板语法中，维的顺序与等价的二维数组相反。使用ArrayTP模板创建了一个一维数组，来分别保存着10个组的总数和平均值。方法调用cout.width(2)以两个字符的宽度显示下一个条目（如果整个数字的宽度不超过两个字符。）


