// 初始化顺序
当初始化列表包含多个项目时候，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序。

// 使用被包含对象的结果
被包含对象的接口不是共有的，但可以在类方法中使用他，


//私有继承
C++还有另一种实现has-a关系的途径-私有继承。使用私有继承，积累的共有成员和保护成员将将称为派生类的私有成员，这意味着
积累方法将不会称为派生类对象共有接口的一部分，但可以在派生类的成员函数中使用它们。

使用共有继承，基类的共有方法将称为派生类的共有方法。总之，派生类将继承基类的接口：这是is-a关系的一部分。使用私有继承，基类的共有方法将称为派生类的私有方法。总之，派生类不继承基类的接口。正如从被包含对象中看到的，这种不完全继承是has-a关系的一部分。

使用室友继承，类将继承事项。例如，如果从string类派生出Student类，后者将有一个string类组件，可以用于保存字符串。另外，Student方法可以使用String方法来访问String组件。

包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象来表示通过继承或包含添加的对象。

因此私有继承提供的特性与包含相同：获得实现，但不获得接口。所有室友继承可以用来实现has-a关系，

## 使用私有继承还是包含呢？

由于既可以使用包含，也可以使用私有继承来建立has-a关系，那应该使用那种方式呢？大多数C————程序员倾向于使用包含，首先，
它易于理解，类声明中包含表示被包含类的显示命名对象，代码可以通过名称引用这些对象，而使用继承将是关系更加抽象。其次，继承会引起很多问题，尤其是从多个基类继承时，可能必须处理很多问题，如包含同名方法的独立的基类或者共享祖先的独立基类，总之，使用包含不太可能遇到这样的麻烦。另外，包含能够使用多个同类的子对象，而继承只能使用要一个这样的对象。

然而，私有继承所提供的特性确实比包含多，例如，假设类包含保护成员，而这样的成员在派生类中是可用的，但在继承基层外是不可用的。如果使用组合将这样的类包含在另一个类中，则后者将不是派生类，而是位于基层乘此之外的，因此不能访问保护成员，但通过继承得到的是派生类，恶意获取保护成员。

另一种需要使用是由继承的情况是需要重新定义虚函数。派生类可以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将只能在类中使用，而不是共有的。

## 保护继承

保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected：

使用保护继承时，基类的共有成员和保护成员都将称为派生类的保护成员。和私有继承一样，基类的接口在派生类中是可以用的，但是在基层层次之外是不可用的。当从派生类派生出另一个类时，私有继承和保护继承之间的区别就呈现出来了。使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的共有方法在派生类中编程了私有方法；使用保护继承时候，基类的公有方法在第二代中变成受保护的，因此第三代派生类可以使用它们。

## 使用using重新定义访问权限

使用保护派生或室友派生时候，基类的共有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用。方法之一是定义一个使用该基类方法的派生类方法。例如，假设希望Student类能够使用valarray类的sum方法，可以在Studeng类的声明中声明一个sum方法，然后像下面这种定义该方法：
double Student::sum() const {
    return std::valarray<double>::sum();  
}

这样Student对象便能够调用Studnet::sum()，后者进而将valarray<double>:sum()方法应用于被包含的valarray对象。

另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用特定的基类成员，即使采用
的是私有派生。；例如，假设希望能够通过Studnet类能够使用valarray的方法min和max，可以在studenti.h的共有部分加入如下的using
声明：

class Student : private std::string, private std::valarray<double> 
{
public:
    using std::valarray<double>::min;
    using std::valarray<double>::max;
    ...
}

上述using声明使得这两个函数可用，就像它们是Student的共有方法一样。

注意：using声明只使用成员名-没有圆括号、函数特征符和返回类型。例如，为使Student类可以使用valarray的operator[]()方法，只需要在Student类声明的共有部分包含下面的using声明。

using std::valarray<double>::operator[];

这将使两个版本都咳哟i哦那个，便可以删除Student::operator[]()的原型和定义。using声明是适用于继承，二不适用于包含，

有一种老式方式可用于在私有派生类中重新重新声明基类方法，即将方法名放在派生类的共有部分

## 多重继承

多重继承可能会给程序员带来很多新问题。其中两个主要的问题是：从两个不同的基类继承同名方法：从两个或者更多相关基类那里继承同一个类的多个实例。为解决这些问题，需要使用一些新的规则和不同的语法。因此，与使用单继承相比，使用多重继承更加困难，也更容易出现问题。由于这个原因，很多C++用户强烈反对使用多重继承，一些人甚至希望删除多重继承，而喜欢多重继承的人则认为，对于一些特殊的工程来说，多重继承很有用，甚至是必不可少的。；

下面来看一个问题，并介绍有哪些问题以及如何解决它们。要使用多重继承，需要几个类，我们将定义一个抽象基类worker，并使用它派生出waiter和singer类，然后，便可以使用多重继承从Waiter类和Singer类派生出SingingWaiter类。这里使用两个独立的派生来使基类被继承，浙江导致多重继承的大多数麻烦。

## 虚基类
虚基类使得从多个类派生出来的对象只继承一个基类对象。例如，通过在类声明中使用关键字virtual,可以是worker被用作Singer和Waiter的虚基类。

现在SingingWaiter对象将只包含worker对象的一个副本。本子上说，继承的Singer和Waiter对象只共享一个Worker对象，而不是格子引入自己的Wroker对象的副本。因为SingingWaiter现在只包含一个worker子对象，所以可以使用多态。

您可能会有这样的疑问：
  1. 为什么术语使用虚
  2. 为什么不抛弃到基类生为旭的这种方式，而使需行为行为多MI的准则的？
  3. 是否存在麻烦呢

首先，为什么使用术语虚？毕竟虚函数和虚基类之间并不存在明显的联系。C++用户强烈反对引入新的关键字，因为浙江给它们带来很大的呀压力，例如，如果新关键字与重要成语中的重要函数或者变量相同，浙江非常麻烦。因此，C++对这种新特性也使用了关键字virtual-有点像关键字重载。

其次，为什么不抛弃将基类声明为虚的这种方式，而使需行为称为MI的准则呢？第一，在一些情况下，可能需要基类的多个拷贝；第二，将基类作为虚的要求程序完成外的计算，为不需要的工具付出代价是不适当的；第三，这样做是有缺点的。

最后，死否存在麻烦呢？是的，为使虚基类能够工作，需要对C————规则进行调整，必须以不同的方式编写代码。另外，使用虚基类还可能需要修改已存在的代码。

## 新的构造规则
使用虚基类时，需要对类构造函数采用一种新的方法。对于非虚基类，唯一可以出现在初始化列表中的构造函数是即使基类构造函数，但这些构造函数可能需要将信息传递给其基类，例如可能有下面一组构造函数：

class A
{
    int a;
public:
    A(int n=0) : a(n) { }
};

class B : public A
{
    int b;
public:
    B(int m=0,int n=0) : A(n),b(m) { }

};

class C : public B
{
    int c;
public:
    C(int q=0,int m=0,int n=0) : B(m,n),c(q) { }
}

C的构造函数只能调用B类的构造函数，而B类的构造函数只能调用A类的构造函数，这里，C类的构造函数使用值q,并将值m,n传递给B类的构造函数；而B类的构造函数使用值m,并将值n传递给A类的构造函数。

如果Worker是虚基类，则这种信息自动传递将不起作用。例如，对于下面的MI构造函数：
SingingWaiter(const Worker& wk,int p=0,int v=Singer::other) : Waiter(wk,p),Singer(wk,v) { }

存在的问题是，自动传递信息时候，将通过2条不同的途径将wk传递给Worker对象。为避免这种冲突，C++在基类是虚的时，禁止信息通过中间类自动传递给基类。因此，上述构造函数将初始化成员panache和voice，但wk参数中的信息不会传递给子对象waiter。然而，编译器必须在构造派生对象之前构造基类对象组件；在这种情况下bian

