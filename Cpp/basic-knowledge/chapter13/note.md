C++类提供了更高层次的重用性。目前，很多厂商提供了类库，类库由类声明和实现构成。
因为类组合了数据表示和类方法，因此提供了比函数库更加完整的程序包。例如，单个类
就可以提供用于管理对话框的全部资源。通常，类库是以源代码的方式提供的，这意味着可以对其进行
修改，以满足需求。然而，C++提供了比修改代码更好的方法来扩展和修改类。这种方法就做类继承，
他能够从已有的类派生出新的类，而派生类集成了原有类的特征，包括方法。正如继承一笔财产要比
自己白手起家更加容易一些，通过集成派生出的类通常比涉及心得要容易的多。
下面是可以通过集成完成的一些任务。
1. 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算
2. 可以给类添加数据，例如，对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据曾元
3. 可以修改类方法的行为。
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，RatedPlayer构造函数不能直接设置集成的成员，而必须使用积累的共有方法来访问是由的积累成员。



### 有关派生类构造函数的要点如下：
1. 首先创建基类对象
2. 派生类构造函数营通过成员初始化列表将基类信息传递给基类构造函数
3. 派生类构造函数应该初始化新增的数据成员。

注意：创建派生类对象时，程序首先调用基类钩爪函数，然后再调用派生类构造函数。基类的构造函数负责初始化集成的数据成员，派生类
构造函数主要用于初始化新增的数据成员。派生类的构造函数总是会调用一个基类的函数。可以使用初始化列表语法指明要使用的基类构造函数，否则使用默认的基类构造函数。

派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类析构函数。

## 派生类和基类的关系
1. 派生类对象可以使用基类的方法（条件是方法不是私有的）
2. 基类指针可以再不进行显示类型转换的情况下指向派生类对象，
3. 基类引用可以再不进行显示类型转换的情况下引用派生类对象。
4. 但是基类指针或引用只能用于调用基类方法。
5. 通常C++要求引用和指针类型对赋给的类型匹配，但这以规则对集成来说是例外的。然而，这种例外只是
   单向的，不可以将基类对象引用和地址付给派生类引用和指针。
   分析： 如果将派生类付给基类（基类指向派生类），派生类对象继承了基类的方法，因此，这样做不会出问题
          如果将基类对象赋给派生类引用，派生类引用能够为基类对象调用派生类方法，这样做是有问题的。
          


## C++有三种继承方式
1. 公有继承
2. 保护继承
3. 私有继承

## 多态
定义：同一个方法再派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象。这种行为称为多态。
公有继承多态的实现：
    1. 再派生类中重新定义基类的方法
    2. 使用虚函数

## 为何需要虚析构函数？
  使用delete释放有new分配的对象的代码说明了为何基类应该包含一个虚虚构函数，
虽然有时好像并不需要析构函数，如果析构函数不是虚的，则将只调用对应于指针类型的析构函数，
即只调用基类的析构函数，即使指针指向的是一个子类对象。如果析构函数是虚的，将调用相应对象类型的析构函数，因此，如果
指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用，对于


## 静态联编和动态联编
    程序调用函数时，将使用那个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中，着非常简单，因为每个函数名都对一个不通的函数。在C++中。由于函数重载的缘故，这项任务更加复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而，C++编译器可以在编译过程完成这种联编。在编译过程中进行联编称为静态联编。然而虚函数使得这项工作变得更加困难，即使用哪一种函数是不能在编译时确定的，因为编译器不知道用户选择那种类型的对象。所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编。


