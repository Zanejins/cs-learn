C++类提供了更高层次的重用性。目前，很多厂商提供了类库，类库由类声明和实现构成。
因为类组合了数据表示和类方法，因此提供了比函数库更加完整的程序包。例如，单个类
就可以提供用于管理对话框的全部资源。通常，类库是以源代码的方式提供的，这意味着可以对其进行
修改，以满足需求。然而，C++提供了比修改代码更好的方法来扩展和修改类。这种方法就做类继承，
他能够从已有的类派生出新的类，而派生类集成了原有类的特征，包括方法。正如继承一笔财产要比
自己白手起家更加容易一些，通过集成派生出的类通常比涉及心得要容易的多。
下面是可以通过集成完成的一些任务。
1. 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算
2. 可以给类添加数据，例如，对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据曾元
3. 可以修改类方法的行为。
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，RatedPlayer构造函数不能直接设置集成的成员，而必须使用积累的共有方法来访问是由的积累成员。



### 有关派生类构造函数的要点如下：
1. 首先创建基类对象
2. 派生类构造函数营通过成员初始化列表将基类信息传递给基类构造函数
3. 派生类构造函数应该初始化新增的数据成员。

注意：创建派生类对象时，程序首先调用基类钩爪函数，然后再调用派生类构造函数。基类的构造函数负责初始化集成的数据成员，派生类
构造函数主要用于初始化新增的数据成员。派生类的构造函数总是会调用一个基类的函数。可以使用初始化列表语法指明要使用的基类构造函数，否则使用默认的基类构造函数。

派生类对象过期时，程序首先调用派生类析构函数，然后再调用基类析构函数。

## 派生类和基类的关系
1. 派生类对象可以使用基类的方法（条件是方法不是私有的）
2. 基类指针可以再不进行显示类型转换的情况下指向派生类对象，
3. 基类引用可以再不进行显示类型转换的情况下引用派生类对象。
4. 但是基类指针或引用只能用于调用基类方法。
5. 通常C++要求引用和指针类型对赋给的类型匹配，但这以规则对集成来说是例外的。然而，这种例外只是
   单向的，不可以将基类对象引用和地址付给派生类引用和指针。
   分析： 如果将派生类付给基类（基类指向派生类），派生类对象继承了基类的方法，因此，这样做不会出问题
          如果将基类对象赋给派生类引用，派生类引用能够为基类对象调用派生类方法，这样做是有问题的。
          


## C++有三种继承方式
1. 公有继承
2. 保护继承
3. 私有继承

## 多态
定义：同一个方法再派生类和基类中的行为是不同的，换句话说，方法的行为应取决于调用该方法的对象。这种行为称为多态。
公有继承多态的实现：
    1. 再派生类中重新定义基类的方法
    2. 使用虚函数

## 为何需要虚析构函数？
  使用delete释放有new分配的对象的代码说明了为何基类应该包含一个虚虚构函数，
虽然有时好像并不需要析构函数，如果析构函数不是虚的，则将只调用对应于指针类型的析构函数，
即只调用基类的析构函数，即使指针指向的是一个子类对象。如果析构函数是虚的，将调用相应对象类型的析构函数，因此，如果
指针指向的是BrassPlus对象，将调用BrassPlus的析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用，对于


## 静态联编和动态联编
    程序调用函数时，将使用那个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。在C语言中，着非常简单，因为每个函数名都对一个不通的函数。在C++中。由于函数重载的缘故，这项任务更加复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而，C++编译器可以在编译过程完成这种联编。在编译过程中进行联编称为静态联编。然而虚函数使得这项工作变得更加困难，即使用哪一种函数是不能在编译时确定的，因为编译器不知道用户选择那种类型的对象。所以，编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编。

1. 会什么会有两种类型的联编以及为什么默认为静态联编
   如果动态联编让您能够重新定义类方法，而静态联编在这方面很差，为什么不放弃静态联编呢？原因有两个-效率和概念模型。首先说效率。为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，着增加了额外的处理开销。如，如果类不会用作基类，则不需要动态联编。同样，如果派生类不重新定义基类的任何方法，也需要动态联编。在这些情况下，使用静态联编更好，效率更高。由于静态联编的效率高，因此被设置为C++的默认选择，C++的指导原则之一是，不要为不适用的特性付出代价（内存或者处理时间）。仅当程序设计确实需要虚函数时候，才使用它们。

   记下来是概念模型。在设计类时，可能包含一些不在派生类重新定义的成员函数，例如

### 虚函数的工作原理
通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表。虚函数表中存储了为类对象声明的虚函数的地址，例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个质量独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也被调价到vtbl中。注意，无论类中包含的虚函数是一个还是10个，都只需要在对象中添加一个地址成员，只是表的大小不通而已。

调用虚函数时候，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。

总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：
 1. 每个对象都将增大，增大量为存储地址的空间
 2. 对于每个类，编译器都要创建一个虚函数的地址表
 3. 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

我们已经讨论了虚函数的一些要点：
 1. 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚的。
 2. 如果使用指向对象的引用或者指针来调用虚方法，程序将使用为对象类型定义的方法，而
    不使用为引用或者指针类型定义的方法，着称为动态联编。
 3. 如果定义的类将被用作基类，则应将哪些在派生类中重新定义的类方法声明为虚的。


 ## Protected
 Protected： 类外不能访问      派生类可以访问
 private:    类外不能访问      派生类不可以访问
 public:     类外可以访问      派生类可以访问。


### 抽象基类概念
1. 构想基类描述的是至少使用一个存虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。

2. 

## 继承和动态内存分配
1. 第一种情况：派生类不使用new
   当基类采用动态内存分配，且已经正确处理析构函数、复制构造函数、赋值运算符是，派生类没有使用new，则不需要再显示的定义析构函数、赋值构造函数、赋值运算符。
2. 第二种情况：派生类使用new
   当基类和派生类都采用动态内存分配时候，派生类的析构函数、复制构造函数、复制运算符都必须使用相应的基类方法来处理基类元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这时自动完成的；对于拷贝钩爪函数，这时通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于复制运算符，这时通过使用作用域解析运算符显示的调用基类的复制运算符。


## 有关基类方法的说明
1. 派生类对象自动使用继承而来的基类方法，如果派生类没有重新定义该方法
2. 派生类的构造函数自动调用基类的构造函数
3. 派生类的构造函数自动调用基类的构造函数，如果没有在成员初始化列表中指定其他构造函数。
4. 派生类构造函数显示的调用成员初始化列表中指定的基类构造函数
5. 派生类方法可以使用作用域接媳妇来调用public和protected的基类方法
6. 派生类的友元函数可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。